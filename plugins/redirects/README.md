Use the 'redirects' key to set up .htaccess redirects. The most common use case would be to map legacy URLs to new ones. Redirects defined at the top level are shared across all .htaccess files. See also file-level.

You may also use this to return 1XX,2XX,4XX,5XX codes when a certain URL is hit. Most common use would be to forbid a url. @see "Handling Errors" below.

* <https://developer.mozilla.org/en-US/docs/Web/HTTP/Status>

## Regex is supported, see example below.

## Path Preprocessing During Build

This plugin tries to "improve" your configured path by adding regexp syntax to it. This is why you will see small changes in the generated output file compared to your configued paths. In some cases this is undesired.

To **prevent regexp escaping/modification** of your configuation path, you must use delimiters, either `#` or `@`.  **Using `/` as delimitter is NOT supported because that is a common URL character.**  Both examples below will result in the same output, which is `^/\.git(/|$)`; that is to say the only processing that occurs is the stripping of the delimitters.

```yaml
redirects:
  404:
    - '#^/\.git(/|$)#'
    - '@^/\.git(/|$)@'
```

## Other status codes can be returned by giving the numeric status code as the value of status.

* If the status is between 300 and 399, the URL argument must be present.
* If the status is not between 400 and 499, the URL argument must be omitted.
* The status must be a valid HTTP status code, known to the Apache HTTP Server (see the function send_error_response in http_protocol.c).

To learn more see: https://httpd.apache.org/docs/current/mod/mod_alias.html#redirectmatch

```shell
redirects:
  301:
    - /some/old/path /some/new/path

    # Notice the use of the escaped $, e.g. '\$' in this example for the replace
    # side of this line.
    - /foo/(.+) /bar/\$1
  403:
    - /some/forbidden/path
```

## Handling Errors

In some server configurations, error traffic (like 403 or 404) is automatically routed to a front-controller (e.g., `index.php`) to bootstrap a full application. This can be slow and unnecessary for simple error responses. The `redirects.error_handlers` feature allows you to bypass the main application and serve a lightweight, fast response instead.

**Only enable this feature in environments where you notice your error handling is going to the app; otherwise, don't use it, as Apache's native error handling is faster.**

To use this, add the status code(s) to one or more items in the `files` configuration as `redirects.error_handlers`. When an URL matches a redirect with one of these status codes, a small, autogenerated handler file (e.g., `_handle-404.php`) will be called to serve the status code.

You may add `redirects.error_handlers` to the root (global) level, or to the files.* level to limit to individual files.  `inherit: false` works to skip a single `files.*` if that is more appropriate for your configuration.

```yaml
files:
  .htaccess:
    webroot: ./web
    redirects:
      error_handlers: [ 403, 404 ]
      404:
        - /legacy-path-1
        - /legacy-path-2
      403:
        - /private-folder
```

By using `error_handlers`, the server will return the error status response immediately via the generated script, without the overhead of bootstrapping your entire application.
